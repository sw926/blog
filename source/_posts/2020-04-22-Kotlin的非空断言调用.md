---
title: Kotlin的非空断言调用
date: 2020-04-22 09:08:33
category: Kotlin
tags: 
    - Kotlin
---

Kotlin 中使用 if 进行判空后就可以在 if 代码块中安全使用了，但这只针对 val 类型的变量，非空的 var 类型变量在 代码块中使用还是会显示编译错误，但是在 let 代码块内就可以安全使用，原因有可能是变量可以在其他线程置为 null，例如：

``` kotlin
import java.util.concurrent.ThreadLocalRandom

class Foo {
    val name = "bar"
}

var foo: Foo? = Foo()

fun main() {
    Thread(Runnable {
        test1()
    }).start()
    Thread.sleep(1000)
    foo = null
    Thread.sleep(3000)
}

fun test1() {
    foo?.let {
        Thread.sleep(2000)
        println(it.name)
    }
}
```

在 `println(foo!!.name)` 一定会抛出空指针异常。
如果把 if 换成 let， 程序就能正常打印了：

```
fun test2() {
    foo?.let {
        Thread.sleep(2000)
        println(it.name)
    }
}
```

通过反编译来生成 Java 代码：

``` java
public static final void test1() {
    if (foo != null) {
        Thread.sleep(2000L);
        Foo var10000 = foo;
        if (var10000 == null) {
            Intrinsics.throwNpe();
        }
        String var0 = var10000.getName();
        System.out.println(var0);
    }
}

public static final void test2() {
    Foo var10000 = foo;
    if (var10000 != null) {
        Foo var0 = var10000;
        Thread.sleep(2000L);
        String var5 = var0.getName();
        System.out.println(var5);
    }
}
```

两个方法的主要区别是 `test2()` 首先执行了一次赋值 `Foo var10000 = foo;`，我的理解是 Foo 对象是保存在堆上，foo 是一个静态的引用，`Foo var10000 = foo;` 这一步操作确保了在函数使用的是函数内的临时变量，不会被修改。
