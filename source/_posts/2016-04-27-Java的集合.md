---
title: Java的集合
date: 2016-04-27 22:21:01
tags: 
    - Java
category: Java
---
# ArrayList和LinkedList的遍历

从最常用的ArrayList说起
```java
public class ArrayList<E> extends AbstractList<E> implements Cloneable, Serializable, RandomAccess
```
RandomAccess这个接口是空的
```java
package java.util;

/**
 * RandomAccess is implemented by {@code List} implementations that support fast
 * (usually constant time) random access.
 */
public interface RandomAccess {
    /* empty */
}
```
在遍历的时候，实现了RandomAccess的List
```java
for (int i=0, i<list.size(); i++) {
    list.get(i)
}
```
要比
```java
for (Iterator i=list.iterator(); i.hasNext();) {
    i.next()
}
```
快，对于LinkedList，是SequentialList
```java
public class LinkedList<E>
    extends AbstractSequentialList<E>
    implements List<E>, Deque<E>, Cloneable, java.io.Serializable
```
也就是说LinkedList遍历的时候要使用迭代器的方法，而不要使用index的方法。
经常使用的foreach方法
```java
for (String s : strings) {
}
```
是使用的Iterator方法，所以遍历ArrayList应该避免使用foreach的方法。
为什么这两种遍历方法在这两种数组上的区别？是因ArrayList是基于动态数组的数据结构，而LinkedList是基于列表。

# ArrayList和LinkedList的使用场景

ArrayList和LinkedList在性能上各有优缺点，都有各自所适用的地方，总的说来可以描述如下： 
1．对ArrayList和LinkedList而言，在列表末尾增加一个元素所花的开销都是固定的。对ArrayList而言，主要是在内部数组中增加一项，指向所添加的元素，偶尔可能会导致对数组重新进行分配；而对LinkedList而言，这个开销是统一的，分配一个内部Entry对象。

2．在ArrayList的中间插入或删除一个元素意味着这个列表中剩余的元素都会被移动；而在LinkedList的中间插入或删除一个元素的开销是固定的。

3．LinkedList不支持高效的随机元素访问。

4．ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间

可以这样说：当操作是在一列数据的后面添加数据而不是在前面或中间,并且需要随机地访问其中的元素时,使用ArrayList会提供比较好的性能；当你的操作是在一列数据的前面或中间添加或删除数据,并且按照顺序访问其中的元素时,就应该使用LinkedList了。

# Vector和Stack
![collection](/images/collection.jpg)
通过上图，可以看到还有两个实现了RandomAccess的集合类，Vector和Stack
Vector和ArrayList类似，不过Vector是线程安全的
关于ArrayList和Vector区别如下：

1. ArrayList在内存不够时默认是扩展50% + 1个，Vector是默认扩展1倍。
2. Vector提供indexOf(obj, start)接口，ArrayList没有。
3. Vector属于线程安全级别的，但是大多数情况下不使用Vector，因为线程安全需要更大的系统开销。

参考：
<http://pengcqu.iteye.com/blog/502676>
<http://www.blogjava.net/lzqdiy/archive/2007/04/22/112578.html>
<http://www.cnblogs.com/wanlipeng/archive/2010/10/21/1857791.html>
